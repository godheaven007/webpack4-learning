## 4章

### 4-1 tree shaking


2.0 

```
main.js
export const add = (a, b) => {
	console.log( a + b );
}

export const minus = (a, b) => {
	console.log( a - b );
}


index.js

import { add } from './math.js';
add(1, 2);
```

在上述代码中，我们只使用了 add, 没有使用minus  
但是在最后打包中，main.js 也打包了 minus 方法  
这是我们不需要的  
翻译过来是，摇树，把不需要的去掉  


> 定义

当我引入一个文件时，不需要引入这个文件所有代码，只引入我们需要的代码


> 特点

1. 只支持es模块引入，只支持 import , 不支持 require 方式
2. import 静态引入方法，require 动态引入
3. develop 模式需要配置optimization 和 package.json， production环境只需要配置 package.json

```
//package.json
// 正常对所有模块做tree shaking, 没有不需要tree shaking的代码
sideEffects: false
	
	
//webpack.config.js
entry:
optimization: {
	usedExports: true
},
```
 
 
### 4-2  develop 和 production 模式
 
 
在切换开发和上线模式，需要修改  webpack.config.js  文件的配置

mode  
devtool  
optimization 等  

非常麻烦
 
 
> 方法：

我们使用两个 配置项文件  
webpack.dev.js  
webpack.prod.js  
 
 
 在 package.json 中配置使用哪个文件的配置项即可
 
```
 "scripts": {
    "dev": "webpack-dev-server --config ./webpack.dev.js",
    "build": "webpack --config ./webpack.prod.js"
 },
``` 
 
 改过webpack配置需要重启服务器
 
 
 
 抽取 webpack.dev.js  webpack.prod.js   相同的代码，放到 webpack.common.js 文件中，
 
 ```
const webpack = require('webpack');
const merge = require('webpack-merge');
const commonConfig = require('./webpack.common.js');

const devConfig = {
	mode: 'development',
	devtool: 'cheap-module-eval-source-map',
	devServer: {
		contentBase: './dist',
		open: true,
		port: 8080,
		hot: true
	},
	plugins: [
		new webpack.HotModuleReplacementPlugin()
	],
	optimization: {
		usedExports: true
	}
}
 
module.exports = merge(commonConfig, devConfig); 
 ```
 
 把 三个webpack 文件都放到build文件夹下，我们还需要修改配置
 
 ```
 package.json
 
 "scripts": {
    "dev": "webpack-dev-server --config ./build/webpack.dev.js",
    "build": "webpack --config ./build/webpack.prod.js"
 },

 ```
 
 
 
### 4-3 code spliting


> build 文件夹相关配置 
 
```
plugins: [
	new HtmlWebpackPlugin({
		template: 'src/index.html'
	}), 
	new CleanWebpackPlugin(['dist'])
],
	
output: {
	filename: '[name].js',
	path: path.resolve(__dirname, 'dist')
}
```
问题： 打包生成的 文件夹是在 和 当前文件 webpack.common.js 同级，也就是会在build 文件夹下，生成一个dist文件夹，这是我们不希望的

clean 也清楚的是 build下的dist文件夹  
我们想删除，和build 同级的dist文件夹

修改后

```
plugins: [
	new HtmlWebpackPlugin({
		template: 'src/index.html'
	}), 
	new CleanWebpackPlugin(['dist'], {
		root: path.resolve(__dirname, '../')  //lesson 目录才是根目录，重新定义根目录，之前默认 build 是根路径
	})
],

output: {
	filename: '[name].js',
	path: path.resolve(__dirname, '../dist')
}
```
 
 
 > 什么是代码分割？
 
 场景：我们在一个js文件中，引入了一个工具库 如 loadash，那么在打包的时候，会把工具内库和业务逻辑代码，统一打包在一起，生成到main.js 中
 
 
 > 带来的问题
 
 1. 打包文件会很大，加载时间会长
 2. 内库一般代码是不变的，业务逻辑是经常变的，但是业务逻辑的改变，会导致每次重新打包

```
loadash.js

import _ from 'loadash.js'
window._ = _;


entry: {
	loadsh: 'loadsh.js'
	main: './src/index.js'
}
```
 
 
> 分割优点

main.js 被拆分成 loadsh.js 和 main.js 两个文件  
当页面业务逻辑发生变化时，只需要加载main.js 即可

> webpack   对代码分割的支持
 
 使用插件，splitChunksPlugin
 
 ```
 optimization: {
 	splitChunks: {
 		chunks: 'all'
 	}
 }
 ```
 
 当遇到公用内库，自动的拆分 内库 和 业务代码
 
 
 除了同步引入模块，我们还可以异步引入模块
 
 
 import 后面可以是 then么？
 
```
 function getComponent() {
	return import('lodash').then(({ default: _ }) => {
		var element = document.createElement('div');
		element.innerHTML = _.join(['Dell', 'Lee'], '-');
		return element;
	})
}
```
 
[回答参考：](http://www.imooc.com/wenda/detail/534152)
 
 import()是个语法糖，返回值是一个Promise对象，意味着这需要异步处理，你可以在.then()中拿到真正的模块。基于这点，你的截图其实是这样的：

```
{
 component: () => {
   return import('xxx');
 },
}
```
把import包裹在函数中，当真正用到模块的时候，才执行 component().then()。这就是懒加载了
 
 
 > 总结：
 
代码分割，和webpack无关  
webpack中实现代码分割，两种方式  

1. 同步代码： 只需要在webpack.common.js中做optimization的配置即可
2. 异步代码(import): 异步代码，无需做任何配置，会自动进行代码分割，放置到新的文件中
 
### 4-5 代码分割参数配置


无论我们使用同步和异步打包，都需要 使用 splitChunkPlugin 这个插件

```
optimization: {
  splitChunks: {
  chunks: 'all',       同步和异步的代码都进行代码分割
  chunks: 'async',     只对异步代码生效
  minSize: 30000,      内库低于某个值，不会做代码分割
  maxSize: 50000,      如果打包后1mb, 会尝试进行二次拆分
  minChunks: 1,        最少使用次数，最少import 一次
  maxAsyncRequests: 5, 同时异步引入模块，如果超过5个，后面不进行分割了
  maxInitialRequests: 3,     入口文件，最多分割成3个
  automaticNameDelimiter: '~',  生成文件连接符，vendors~main.js
  name: true,
  //如果是同步引入模块，会进入 cacheGroups
  cacheGroups: {
    vendors: {
    //如果是同步代码分割，需要配置test，表示引入库来源于node_modules， 单独打包到新的文件夹，或者生成新文件
      test: /[\\/]node_modules[\\/]/,
      priority: -10,   //进入缓存组的优先级
      // filename: 'vendors.js',
    },
    default: {
      priority: -20,
      reuseExistingChunk: true,
      filename: 'common.js'
    }
  }
}
```

### 4-6 

讲解示例，为什么设置 minSize: 0 没有进行代码分割？  

原因： 此时 import test from './test.js'  

是同步引入，同步引入虽然设置了minSize: 0  

但是会进入 cacheGroups 设置  

test 是自己写的，显然不是来源于node_modules  

那么我们会读取 default 中的配置，写入到 common.js 中  





### 4-7  lazy loading chunking 懒加载是什么


> 示例：点击后再 import 引入异步模块

通过 import 对一些模块进行懒加载


执行import 语法，才会去加载 相应的js

路由使用了懒加载




> 什么是chunk?

打包后生成了几个js, 我们就叫它几个 chunk




```
minChunks: 2,        最少使用次数，最少import 2次
```

打包生成的文件，有几个使用了loadash

最后，我们生成了几个 chunk文件，如果生成的chunk中，至少有2个文件，使用了 import 组件 ，那么我们就对这个 import 文件（loadash）进行分割








### 4-8 打包分析，preloading , prefetching

对打包进行分析，看打包是否合理

"scripts": {
    "dev-build": "webpack --profile --json > stats.json --config ./build/webpack.dev.js",
    "dev": "webpack-dev-server --config ./build/webpack.dev.js",
    "build": "webpack --config ./build/webpack.prod.js"
  },


生成了 stats.json 文件

工具可以根据 stats.json 文件 进行分析


webpack , 默认只对异步代码，进行代码分割

optimization: {
splitChunks: {
  chunks: 'async' 
 }
}



如何看一个网站代码使用率？
打开控制台，输入coverage


把交互部分代码放到另外一个js文件中




